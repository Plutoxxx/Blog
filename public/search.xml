<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础①</title>
      <link href="/2019/10/27/java1/"/>
      <url>/2019/10/27/java1/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><hr><h2 id="对象和封装"><a href="#对象和封装" class="headerlink" title="对象和封装"></a>对象和封装</h2><ol><li>当一个对象作为参数，传递到方法中时，实际上传递的是地址值。</li><li><strong>局部变量、成员变量区别</strong></li></ol><ul><li><p>定义的位置不一样(<strong>重点</strong>)<br>局部：在方法的内部。<br>成员：在方法的外部，直接写在类当中。</p></li><li><p>作用范围不一样(<strong>重点</strong>)<br>局部：只在方法当中才有用，出了方法就不能用了。<br>成员：整个类都能使用。</p></li><li><p>默认值不同(<strong>重点</strong>)<br>局部：没有默认值，要想用，必须手动赋值。<br>成员：如果没有赋值，会有默认值，规则和数组一样。</p></li><li><p>内存的位置不一样(了解)<br>局部：位于栈内存。<br>成员：位于堆内存。</p></li><li><p>生命周期不一样<br>局部：随着方法进栈而诞生，随着方法的出栈而消失。<br>成员：随着对象创建而诞生，随着对象被垃圾回收而消失。</p></li></ul><ol start="3"><li><p>封装就是将一些细节信息隐藏起来，对外界不可见。</p></li><li><p>构造方法是专门用来创建对象的方法，当我们利用关键字new来创建对象时，其实就是调用的构造方法。格式如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//无参构造方法</span><span class="token keyword">public</span> <span class="token function">class_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 方法体<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//有参构造方法</span><span class="token keyword">public</span> <span class="token function">class_name</span><span class="token punctuation">(</span>type name<span class="token punctuation">)</span><span class="token punctuation">{</span> 方法体<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol><li><p>在继承中，“子类就是一个父类”，就是说子类可以被当成一个父类看待。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//父类格式：</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Fu_class</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//子类格式：</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Zi_class</span> <span class="token keyword">extends</span> <span class="token class-name">Fu_class</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在子类中，访问变量的方式如下：</p><pre class="line-numbers language-java"><code class="language-java">局部变量：name本类成员变量：<span class="token keyword">this</span><span class="token punctuation">.</span>name父类成员变量：<span class="token keyword">super</span><span class="token punctuation">.</span>name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>重写((override)):在继承关系中，方法名称一样，参数列表也<strong>一样</strong>。<br>重载((overload)):方法名称一样，参数列表<strong>不一样</strong>。</p></li><li><p>重写注意事项：</p></li></ol><ul><li>必须保证父子类之间的名称相同，参数列表也相同,利用<code>@Override</code>来检测是不是有效的覆盖重写<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">name</span><span class="token punctuation">(</span>type parameter_name<span class="token punctuation">)</span><span class="token punctuation">{</span>  方法体<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>子类方法的返回值必须<strong>小于等于</strong>父类方法的返回值范围</li><li>子类方法的权限必须<strong>大于等于</strong>父类方法的权限修饰符<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">></span> <span class="token keyword">protected</span> <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">default</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token keyword">private</span><span class="token comment" spellcheck="true">//default指的是留空，不写</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><ol start="4"><li><p>继承关系中，父类构造方法的访问特点：<br>子类必须调用父类构造方法，不写则赠送一个<code>super()</code>方法，写了则用指定的super调用，super只能有一个，还必须是第一个。</p></li><li><p>继承中super关键字的用法有3种：</p></li></ol><ul><li>在子类的<strong>成员方法</strong>中，访问父类的<strong>成员变量</strong>。</li><li>在子类的<strong>成员方法</strong>中，访问父类的<strong>成员方法</strong>。</li><li>在子类的<strong>构造方法</strong>中，访问父类的<strong>构造方法</strong>。</li></ul><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ol><li><p>抽象方法：在权限修饰符后加上<code>abstract</code>关键字，去掉大括号，分号结束。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">method_name</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>抽象类：在class前加上<code>abstract</code>即为抽象类。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">class_name</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用抽象类和抽象方法：</p></li></ol><ul><li>不能直接<code>new</code>（创建）抽象类对象</li><li>必须用一个子类来继承抽象父类</li><li>子类必须覆盖重写（去掉<code>abstract</code>关键字，写方法体）抽象父类中的所有抽象方法</li><li>创建子类对象进行使用</li></ul><h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h2><ol><li>接口使用步骤：</li></ol><ul><li><p>建立一个<code>Interface</code>类，里边写抽象方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Interface <span class="token class-name">Interface_name</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>接口不能直接使用，必须有一个“实现类”来“实现”该接口</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">imp_name</span> <span class="token keyword">implements</span> <span class="token class-name">Interface_name</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>接口的实现类必须覆盖重写（实现）接口中<strong>所有</strong>的抽象类</p></li><li><p>创建实现类的对象，进行使用</p></li></ul><ol start="2"><li><p>接口中定义”成员变量”，使用<code>public static final</code>进行修饰，格式：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//其中public static final可以省略，但是不写，默认也是这样</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> type var_name <span class="token operator">=</span> value<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>类-接口：</p></li></ol><ul><li>类与类之间是单继承，直接父类只有一个</li><li>类与接口之间是多实现的，一个类可以实现多个接口</li><li>接口与接口之间是多继承的</li><li>多个父接口之间当中的抽象方法如果重复，没有关系</li><li>多个父接口当中的默认方法（<code>defaule</code>关键字）如果重复，那么子接口必须进行默认方法的重写</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ol><li><p>其实就是一句话：父类引用指向子类对象，格式：</p><pre class="line-numbers language-java"><code class="language-java">Fu_class obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Zi_class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//or</span>Interface_name obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">implements_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>多态下成员变量、成员方法使用口诀：</p></li></ol><ul><li>成员变量：编译看左边，运行看左边</li><li>成员方法：编译看左边，运行看右边</li></ul><ol start="3"><li>对象的转型</li></ol><ul><li><p>对象的向上转型，其实就是多态写法，格式：</p><pre class="line-numbers language-java"><code class="language-java">Fu_class obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Zi_class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>对象的向下转型，其实就是[<strong>还原</strong>]动作，格式：</p><pre class="line-numbers language-java"><code class="language-java">Zi_class obj <span class="token operator">=</span> <span class="token punctuation">(</span>Zi_class<span class="token punctuation">)</span> <span class="token function">Fu_obj_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>instance of</code>会得到一个<code>boolean</code>值结果，判断前边的对象能不能作为后边类型的实例</p><pre class="line-numbers language-java"><code class="language-java">obj instance of class_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="四种权限修饰符"><a href="#四种权限修饰符" class="headerlink" title="四种权限修饰符"></a>四种权限修饰符</h2><pre class="line-numbers language-java"><code class="language-java">                    <span class="token keyword">public</span>  <span class="token operator">></span>   <span class="token keyword">protected</span>  <span class="token operator">></span>  <span class="token punctuation">(</span><span class="token keyword">default</span><span class="token punctuation">)</span>  <span class="token operator">></span>  <span class="token keyword">private</span>同一个类<span class="token punctuation">(</span>我自己<span class="token punctuation">)</span>       √            √             √            √同一个包<span class="token punctuation">(</span>我领居<span class="token punctuation">)</span>       √            √             √            ×不同包子类<span class="token punctuation">(</span>我儿子<span class="token punctuation">)</span>     √            √             ×            ×不同包非子类（陌生人） √            ×             ×            ×<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVPR2019目标检测算法总结</title>
      <link href="/2019/09/28/cvpr2019/"/>
      <url>/2019/09/28/cvpr2019/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>目标检测是很多计算机视觉应用的基础，比如实例分割、人体关键点提取、人脸识别等，它结合了目标分类和定位两个任务。</p><p>现代大多数目标检测器的框架是 (two-stage/single-stage)，目标检测被定义为一个多任务学习的过程，主要包括：</p><ul><li><p>区分前景物体与背景，并给它们分配恰当的类别标签。</p></li><li><p>回归相应的位置参数，最大化检测框与(GT\ bounding\ box)的交并比((IoU))或是其他指标。</p></li></ul><h1 id="目标检测主要的优化方向"><a href="#目标检测主要的优化方向" class="headerlink" title="目标检测主要的优化方向"></a>目标检测主要的优化方向</h1><hr><p>二维目标检测实现和优化方向包括backbone、IoU、损失函数、NMS、anchor、one shot learning/zero shot learning等。<br><br><strong>基于目标检测的backbone和特征提取</strong><br>目标检测的backbone一般是基于ImageNet预训练的图像分类网络。图像的分类只关注分类以及感受视野，不用关注目标的定位，目标检测同时还要关注图片的空间信息。如果下采样过多，会导致最后的Feature map很小，小目标很容易被忽略。现在很多基础网络，ResNet、MaskR-CNN、DenseNet、FPN、DetNet、RetinNet等能够提取图像的上下文信息，在特征提取上不断优化。<br><br><strong>基于位置回归的优化算法</strong><br>包括UnitBox、IoU-Net，能够预测检测到的边界框和它们对应的GT bounding box之间的IoU，使得该网络能像其分类模块一样，对检测框的定位精确程度有所掌握，神经网络在Backbone引入IoU-Net做边界修订。<br><br><strong>基于优化损失函数的方法</strong><br>主要有Smooth L1 loss、Smooth L2 loss、Focal loss等<br><br><strong>基于优化NMS的方法</strong><br>主要有Soft-NMS,Softer-NMS,以及Relation Netwrok，ConvNMS，NMS Network，Yes-Net等<br><br><strong>基于Anchor生成的算法</strong><br>有Sliding window、Region Proposal Network（RPN）、CornerNet、meta-anchor等。<br><br><strong>One-shot learning以及Zero shot learning</strong><br>都属于迁移学习领域主要研究的是网络少样本精准分类问题，单样本学习能力。</p><h1 id="GIoU"><a href="#GIoU" class="headerlink" title="GIoU"></a>GIoU</h1><hr><p><a href="http://openaccess.thecvf.com/content_CVPR_2019/papers/Rezatofighi_Generalized_Intersection_Over_Union_A_Metric_and_a_Loss_for_CVPR_2019_paper.pdf" target="_blank" rel="noopener"><strong>论文下载</strong></a></p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>包围框回归是2D/3D视觉任务中的重要模块，不管是目标检测，目标跟踪，还是实例分割，都依赖于对bounding box进行回归，以获得准确的定位效果。</p><p>其中IoU((Intersection\ over\ Union))是使得包围框回归的重要参数。简单来讲就是模型产生的目标框((Result))与 (GT) 的重叠率。可以理解为检测结果与GT的交集比上它们的并集，公式为：</p><p>$$IoU=\frac{Result\bigcap GT}{Result\bigcup GT}$$</p><p>IoU是目标检测中一个重要的概念，在anchor-based的方法中，他的作用不仅用来确定正样本和负样本，还可以用来评价输出框((predict\ box))和(Ground\ Truth)的距离，或者说(predict\ box)的准确性。IoU有一个好的特性就是对尺度不敏感((scale\ invariant))。</p><p>在regression任务中，判断predict box和gt的距离最直接的指标就是IoU，但所采用的loss却不适合，如图所示，在loss相同的情况下，regression的效果却大不相同，也就是说loss没有体现出regression的效果，而IoU却可以根据不同的情况得到不同的数值，能最直接反应回归效果。</p><p><img src="1.png" alt></p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>本文提出用IoU这个直接指标来指导bounding box的回归。与其用一个代理的损失函数来监督学习，不如直接用指标本身来的好。此时损失函数为：<br>$$L_{IoU}=1-IoU$$</p><p>但是直接使用IoU作为损失函数会出现两个问题:</p><ul><li>如果两个框没有相交，根据定义，IoU=0，不能反映两者的距离大小（重合度）。同时因为loss=0，没有梯度回传，无法进行学习训练。</li><li>IoU无法精确的反映两者的重合度大小。如图所示，三种情况IoU都相等，但看得出来他们的重合度是不一样的，左边的图回归的效果最好，右边的最差。<br><img src="2.png" alt></li></ul><p>针对IoU的两个缺点，论文提出了一个新的指标<strong>GIoU</strong>((Generalized\ Intersection\ over\ Union))，如图所示：<br><img src="3.png" alt></p><p>GIoU的定义很简单，就是先计算两个框的最小闭包区域面积，再计算IoU，再计算闭包区域中不属于两个框的区域占闭包区域的比重，最后用IoU减去这个比重得到GIoU。GIoU有如下4个特点：</p><ul><li><p>与IoU相似，GIoU也是一种距离度量，作为损失函数的话，满足损失函数的基本要求。$$L_{GIoU}=1-GIoU$$</p></li><li><p>GIoU对scale不敏感。</p></li><li><p>GIoU是IoU的下界，在两个框无线重合的情况下，IoU=GIoU。</p></li><li><p>IoU取值[0,1]，但GIoU有对称区间，取值范围[-1,1]。在两者重合的时候取最大值1，在两者无交集且无限远的时候取最小值-1，因此GIoU是一个非常好的距离度量指标。</p></li><li><p>与IoU只关注重叠区域不同，GIoU不仅关注重叠区域，还关注其他的非重合区域，能更好的反映两者的重合度。</p></li></ul><p>其实GIoU不仅定义简单，在2D目标检测中计算方式也很简单，计算重合区域和IoU一样，计算最小闭包区域只需要得到两者max和min坐标，坐标围成的矩形就是最小闭包区域。</p><p>GIoU和IoU作为loss的算法如下所示：<br><img src="4.png" alt></p><p>步骤为：</p><ul><li>分别计算GT和Predict Box的面积</li><li>计算Intersection的面积</li><li>计算最小闭包区域面积</li><li>计算IoU和GIoU</li><li>根据公式得到loss</li></ul><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>GIoU loss可以替换掉大多数目标检测算法中bounding box regression，本文选取了Faster R-CNN、Mask R-CNN和YOLO v3 三个方法验证GIoU loss的效果。实验在Pascal VOC和MS COCO数据集上进行。</p><p>效果如下：</p><p><img src="5.png" alt><br><img src="6.png" alt><br><img src="7.png" alt></p><p>可以看出YOLOv3在COCO上有明显涨点，但在其他模型下涨点并不明显，作者也指出了faster rcnn和mask rcnn效果不明显的原因是anchor很密，GIoU发挥作用的情况并不多。</p><p>总体来说，文章的motivation比较好，指出用L1、L2作为regression损失函数的缺点，以及用直接指标IoU作为损失函数的缺陷性，提出新的metric来代替L1、L2损失函数，从而提升regression效果，想法简单粗暴，但work的场景有很大局限性。</p>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DeepLearning </tag>
            
            <tag> 目标检测 </tag>
            
            <tag> CVPR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Github-Netlify博客搭建教程</title>
      <link href="/2019/09/25/blog/"/>
      <url>/2019/09/25/blog/</url>
      
        <content type="html"><![CDATA[<h1 id="我的博客源代码地址"><a href="#我的博客源代码地址" class="headerlink" title="我的博客源代码地址"></a>我的博客源代码地址</h1><hr><p>大家有需要的可以star&amp;fork我的<a href="https://github.com/Plutoxxx/Blog" target="_blank" rel="noopener">博客代码</a>，修改一些配置就可以写文章了。</p><h1 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h1><hr><p>如果你不想重新自定义主题的话，可以直接下载我已经修改过的主题，只要稍微修改一些地方就行：</p><ul><li>在根目录配置文件_config.yml和themes config.yml中修改个人信息。</li><li>在/_config.yml中修改deploy下的repository。</li><li>在/_config.yml中修改baidu_url_submit下的host。</li><li>在themes/_config.yml中修改gitalk。</li></ul><p><strong>当然在个性化设置前环境要先配置好</strong></p><p>平时常用的命令有：</p><pre><code>hexo n &quot;博客名称&quot;  =&gt; hexo new &quot;博客名称&quot;   #这两个都是创建新文章，前者是简写模式hexo p  =&gt; hexo publish   hexo g  =&gt; hexo generate  #生成静态网页hexo s  =&gt; hexo server    #启动服务预览hexo d  =&gt; hexo deploy    #部署hexo clean   #清除缓存，网页正常情况下可以忽略此条命令ctrl + c     #关闭本地服务器</code></pre><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><hr><p>首先下载稳定版本<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>。</p><p>安装选项默认就行，一路Next。</p><p>最后安装好之后，按Win+R打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p><p><strong>添加国内镜像源</strong></p><p>如果没梯子可以使用阿里的国内镜像进行加速</p><pre><code>npm config set registry https://registry.npm.taobao.org</code></pre><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><hr><p>安装完Node.js后，打开终端，输入以下命令：</p><pre><code>npm install -g hexo-clihexo -v  #查看是否安装成功</code></pre><p>在合适的位置新建文件夹，用来存放blog文件，比如我的博客文件在 F:\Project\GitHub\Blog 目录下。</p><p>在该目录下初始化网站，输入 <code>hexo init</code> 初始化文件夹，接着输入 <code>npm install</code> 安装必要组件。 </p><p>到这里，本地网站已经配置结束，输入 <code>hexo g</code> 生成静态网页，然后输入 <code>hexo s</code> 打开本地服务器，</p><p>最后在浏览器中打开: <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就能看到初始化的blog啦。</p><p>最后按 <code>ctrl+c</code> 就能关闭本地服务器了</p><h1 id="安装Git和创建GitHub仓储"><a href="#安装Git和创建GitHub仓储" class="headerlink" title="安装Git和创建GitHub仓储"></a>安装Git和创建GitHub仓储</h1><hr><p><strong>安装Git</strong></p><p>先到<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git官网</a>下载软件。</p><p>安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入 <code>git --version</code> 验证是否安装成功。</p><p><strong>创建GitHub仓储</strong></p><p>到<a href="https://github.com" target="_blank" rel="noopener">GitHub</a>注册一个账号，相信小伙伴们都有吧。然后新建一个项目，如图所示：<br><img src="1.png" alt></p><p>然后设置一下Repository的名字，如图所示，不要勾选下边的 <code>Initalize this repository with a README</code>如下图所示，点击完成就行。<br><img src="2.png" alt></p><h1 id="本地连接GitHub"><a href="#本地连接GitHub" class="headerlink" title="本地连接GitHub"></a>本地连接GitHub</h1><hr><p>右击打开 <code>Git Bash here</code> ，输入:ssh，如图所示，说明配置好了：<br><img src="3.png" alt></p><p>接着输入 <code>ssh-keygen -t rsa</code> （(主要是生成你跟github联系的秘钥key)）连续三个回车，key就生成了。打开C盘用户下的.ssh文件，其中 <code>id_rsa</code> 代表私钥， <code>id_rsa.pub</code> 代表公钥。</p><p>将id_rsa.pub下的内容复制出来，打开GitHub下的Settings<br><img src="4.png" alt></p><p>选择 <code>SSH and GPG keys</code> 中的 <code>New SSH key</code>粘贴进去就行了<br><img src="5.png" alt></p><p>测试连接 <code>ssh -T git@github.com</code>，弹出警告后，填写yes，然后回车，出现以下则表示成功<br><img src="6.png" alt></p><p>在Blog目录下，右击打开Git，输入命令： <code>git init</code>，会出现一个 <code>.git</code> 文件夹</p><p>在项目根目录下,将你的本地项目和新建的repository联系起来:</p><pre><code>git remote add origin https://github.com/your-name/your-Repository.git</code></pre><p>完成后到根目录下：</p><pre><code>git add .                       # 添加文件到暂缓区git commit -m &#39;First commit&#39;    # 将刚刚添加到暂缓区的内容提交到本地仓库.gitgit push --set-upstream origin master #上传到远程仓库(由于是第一次push,所以是这个命令)</code></pre><p>到这里,我们已经将我们的项目推送到GitHub的master分支下面了.接下来我们要对hexo进行一些配置:</p><p>打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。<br>修改最后一行的配置：</p><pre><code>deploy: type: git #部署方式 repository: git@github.com:you-name/your-Repository.git #关联github仓库 branch: run-page #部署分支</code></pre><p>在这里,我们将在这个项目仓库下新建一个run-page分支,至于有什么用,我等一下解释,先跟着我操作起来.</p><p>在当前根目录下将不需要同步的文件和目录写到 <code>.gitignore</code> :</p><pre><code>.DS_StoreThumbs.dbdb.json*.lognode_modules/themes/.deploy*/</code></pre><p>配置好了之后,保存退出,我们重新执行一下:</p><pre><code>$ hexo clean #清理各种缓存和旧文件$ hexo g     #生成静态文件</code></pre><p>最后,我们将public目录同步到Github:</p><pre><code>$ hexo d #部署应用</code></pre><p>在执行这个命令的时候,我们可能会出现如下错误：</p><pre><code>$ ERROR Deployer not found: git</code></pre><p>那是因为我们缺少一个依赖,我们安装一下:</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>然后再次执行一下,执行完成我们到Github，神奇的的事发生了，我们的项目多了一个(run-page),这个分支就是我们后面要用来生成我们到静态页面的。</p><h1 id="部署到Netlify"><a href="#部署到Netlify" class="headerlink" title="部署到Netlify"></a>部署到Netlify</h1><hr><p>我们先到<a href="https://www.netlify.com" target="_blank" rel="noopener">Netlify</a>官网注册一下账号,因为我们是将项目托管到GitHub的,所以我们选择GitHub登录：<br><img src="7.png" alt><br>点击网站新建：<br><img src="8.png" alt></p><p>选择GitHub来源：<br><img src="9.png" alt></p><p>选择刚建的项目：<br><img src="10.png" alt></p><p>进行下一步配置：<br><img src="11.png" alt></p><p>等待一会，Netlify会帮我们生成网站：<br><img src="12.png" alt></p><p>第一次新建的时候,它会随机生成一个Netlify的二级域名,我们可以进行自定义二级域名,点击(“Change site name”)即可进行设置,像这样：<br><img src="14.png" alt><br><img src="15.png" alt></p><p>点击Save,等待Netlify进行热部署即可.</p><p>然后点击创建好的二级域名,成功访问✌️！！！</p><p>以后我们写好博客之后,直接执行：</p><pre><code>$ hexo clean $ hexo g     $ hexo d</code></pre><p>我们的个人博客就会自动进行刷新,是不是超厉害！！</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><hr><p>部署完成之后,可能有的同学会觉得很晕,我画了一个部署的流程图：<br><img src="13.png" alt><br>这就是我们为什么要利用两个分支的原因,我们将我们的项目分支托管到 <code>master</code> ,然后将生成的 <code>public</code> 目录,托管到 <code>run-page</code> 分支,以后我们可以写完博客以后,就可以直接输入：</p><pre><code>$ hexo clean #清理各种缓存和旧文件$ hexo g     #生成静态文件$ hexo d     #推送到GitHub</code></pre><p>进行我们博客的推送,一旦我们推送到run-page分支,Netlify监测到我们的仓库发生了变化,就会根据这个分支的变化进行实时拉取并部署。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
            <tag> Netlify </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
