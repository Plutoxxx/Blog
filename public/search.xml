<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PyCharm配置远程连接</title>
      <link href="/2019/11/09/pycharm/"/>
      <url>/2019/11/09/pycharm/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27588021&auto=1&height=66"></iframe></div><blockquote><p>主要讲解PyCharm远程连接服务器时的相关配置😝。</p></blockquote><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><hr><p>基本上我们使用PyCharm都是在本地进行开发，但是当我们需要在服务器上调试代码时咋办呢？一种是将服务器上的程序下载到本地，调试编写完后上传，这种方法可行，但是每次都要上传下载，较为繁琐。另一种方法就是利用PyCharm远程调试代码咯，只需稍稍配置一下就能实现。</p><h1 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h1><hr><h2 id="SFTP配置"><a href="#SFTP配置" class="headerlink" title="SFTP配置"></a>SFTP配置</h2><p>打开PyCharm，选择<code>Tools/Deployment/Configuration</code>选项<br><img src="1.png" alt><br>配置连接服务器<br><img src="2.png" alt><br>点击<code>Test Connection</code>，显示成功，表明配置正确<br><img src="7.png" alt><br>选择文件传输对应的位置<br><img src="3.png" alt><br>选择不需要同步的文件<br><img src="4.png" alt><br>文件可以手动上传，也可以自动上传<br><img src="10.png" alt></p><h2 id="Interpreter配置"><a href="#Interpreter配置" class="headerlink" title="Interpreter配置"></a>Interpreter配置</h2><p>打开<code>File/Settings/Project Interpreter</code>选项，点击<code>add</code><br><img src="5.png" alt><br>添加服务器解释器<br><img src="6.png" alt><br>选择解释器的位置，以及文件夹的映射关系<br><img src="8.png" alt><br>解释器配置完成后就能看到环境下包含的<code>package</code><br><img src="9.png" alt><br>此时就能愉快的使用PyCharm进行<code>DeBug</code>啦!</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyCharm </tag>
            
            <tag> 服务器配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础②</title>
      <link href="/2019/11/03/java2/"/>
      <url>/2019/11/03/java2/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=551277612&auto=1&height=66"></iframe></div><blockquote><p>主要总结Java中集合相关的知识，若有错误，欢迎更正🤣。</p></blockquote><h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><hr><h2 id="collection常用功能"><a href="#collection常用功能" class="headerlink" title="collection常用功能"></a>collection常用功能</h2><p>Collection是所有单列集合的父接口，Collection中定义了单列集合（List和Set）通用的一些方法，这些方法可以操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>: 把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code>: 清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><h2 id="iterator迭代器"><a href="#iterator迭代器" class="headerlink" title="iterator迭代器"></a>iterator迭代器</h2><h3 id="1-迭代的概念"><a href="#1-迭代的概念" class="headerlink" title="1. 迭代的概念"></a>1. 迭代的概念</h3><ul><li><strong>迭代</strong>：Collection集合元素的通用获取方式。在取出元素之前要先判断集合中有没有元素，如果有，就把这个元素取出来，继续判断，如果还有就再取出来。一直把集合中的所有元素全部取出来。这种取出方式专业术语称为迭代。</li></ul><h3 id="2-iterator接口的常用方法"><a href="#2-iterator接口的常用方法" class="headerlink" title="2. iterator接口的常用方法"></a>2. iterator接口的常用方法</h3><ul><li><code>public E next()</code>: 返回迭代的下一个元素。</li><li><code>public boolean hasNext</code>: 如果仍有元素可以迭代，则返回true。</li></ul><h3 id="3-增强for循环"><a href="#3-增强for循环" class="headerlink" title="3. 增强for循环"></a>3. 增强for循环</h3><ul><li>专门用来遍历数组和集合的，内部原理其实是一个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。格式为：<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span>type var <span class="token operator">:</span> collection集合 or 数组<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List是Collection集合的子接口，不但继承了Collection接口中的方法，而且增加一些根据元素索引来操作集合的特有方法</p><h3 id="1-List接口特点"><a href="#1-List接口特点" class="headerlink" title="1. List接口特点"></a>1. List接口特点</h3><ul><li>它是一个元素存取有序的集合。</li><li>它是一个带有索引的集合，通过索引就可以精确操作集合中的元素</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素</li></ul><h3 id="2-List接口中常用方法"><a href="#2-List接口中常用方法" class="headerlink" title="2. List接口中常用方法"></a>2. List接口中常用方法</h3><ul><li><code>public void add(int index, E element)</code>： 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>：返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>：用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><h3 id="3-ArrayList集合（List子类）"><a href="#3-ArrayList集合（List子类）" class="headerlink" title="3. ArrayList集合（List子类）"></a>3. ArrayList集合（List子类）</h3><ul><li>数据存储的格式是数组结构。元素增删慢，查找快。</li></ul><h3 id="4-LinkList集合（List子类）"><a href="#4-LinkList集合（List子类）" class="headerlink" title="4. LinkList集合（List子类）"></a>4. LinkList集合（List子类）</h3><ul><li>数据存储的结构是链表结构。元素增删快，查询慢。</li><li>里边包含了大量操作首尾元素的方法。</li></ul><ul><li><code>public void addFirst(E e)</code>：将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>：将指定元素添加到此列表的结尾。</li><li><code>public void push(E e)</code>：将元素推入此列表所表示的堆栈。</li><li><code>public E getFirst()</code>：返回此列表的第一个元素。</li><li><code>public E getLast()</code>：返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>：移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>：移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><blockquote><p>tips：使用LinkedList集合特有的方法,不能使用多态。</p></blockquote><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>同样继承自Collection接口，与Collection接口中的方法基本一致。</p><h3 id="1-Set接口特点"><a href="#1-Set接口特点" class="headerlink" title="1. Set接口特点"></a>1. Set接口特点</h3><ul><li>不允许存储重复的元素。</li><li>没有索引，没有带索引的方法，也不能用普通的for循环遍历。</li></ul><h3 id="2-HashSet（Set实现）"><a href="#2-HashSet（Set实现）" class="headerlink" title="2. HashSet（Set实现）"></a>2. HashSet（Set实现）</h3><ul><li>根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于hashCode与equals方法。</li></ul><blockquote><p>tips：必须重写hashCode和equals方法。</p></blockquote><h3 id="3-LinkedHashSet（Set实现）"><a href="#3-LinkedHashSet（Set实现）" class="headerlink" title="3. LinkedHashSet（Set实现）"></a>3. LinkedHashSet（Set实现）</h3><ul><li>数据为链表+哈希表组合的存储结构。</li><li>元素放入取出是有顺序的。</li></ul><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>当方法参数列表已经确定，但是参数个数不确定时，可以用可变参数。格式为：</p><pre class="line-numbers language-java"><code class="language-java">修饰符 返回值类型 <span class="token function">method_name</span><span class="token punctuation">(</span>type <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>var<span class="token punctuation">)</span><span class="token punctuation">{</span>    方法体<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>一个方法的参数列表，只能有一个参数变量。</li><li>如果方法的参数有多个，那么可变参数必须写在参数列表末尾。</li></ul></blockquote><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="1-Map集合特点"><a href="#1-Map集合特点" class="headerlink" title="1. Map集合特点"></a>1. Map集合特点</h3><ul><li>Map集合是一个双列集合,一个元素包含两个值(一个key,一个value)。</li><li>Map集合中的元素,key和value的数据类型可以相同,也可以不同。</li><li>Map集合中的元素,key是不允许重复的,value是可以重复的。</li><li>Map集合中的元素,key和value是一一对应。</li></ul><h3 id="2-HsahMap（Map实现）"><a href="#2-HsahMap（Map实现）" class="headerlink" title="2. HsahMap（Map实现）"></a>2. HsahMap（Map实现）</h3><ul><li>HashMap集合底层是哈希表:查询的速度特别的快。</li><li>hashMap集合是一个无序的集合,存储元素和取出元素的顺序有可能不一致。</li></ul><h3 id="3-LinkedHashMap（HsahMap实现）"><a href="#3-LinkedHashMap（HsahMap实现）" class="headerlink" title="3. LinkedHashMap（HsahMap实现）"></a>3. LinkedHashMap（HsahMap实现）</h3><ul><li>LinkedHashMap集合底层是哈希表+链表(保证迭代的顺序)。</li><li>LinkedHashMap集合是一个有序的集合,存储元素和取出元素的顺序是一致的。</li></ul><h2 id="JDK9新特性"><a href="#JDK9新特性" class="headerlink" title="JDK9新特性"></a>JDK9新特性</h2><p>List、Set、Map接口:里边增加了一个静态的方法of,可以给集合一次性添加多个元素。</p><ul><li><code>static &lt;E&gt; List&lt;E&gt; of​(E... elements)</code>：一次性添加多个元素。</li></ul><blockquote><ul><li>of方法只适用于List接口，Set接口，Map接口，不适用于接接口的实现类。</li><li>of方法的返回值是一个不能改变的集合，集合不能再使用add，put方法添加元素，否则会抛出异常。</li><li>Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础①</title>
      <link href="/2019/10/27/java1/"/>
      <url>/2019/10/27/java1/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22822489&auto=1&height=66"></iframe></div><blockquote><p>主要讲解Java面向对象的基本特性，若有错误之处，望批评指正😆。</p></blockquote><h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><hr><h2 id="对象和封装"><a href="#对象和封装" class="headerlink" title="对象和封装"></a>对象和封装</h2><ol><li>当一个对象作为参数，传递到方法中时，实际上传递的是地址值。</li><li><strong>局部变量、成员变量区别</strong></li></ol><ul><li><p>定义的位置不一样(<strong>重点</strong>)<br>局部：在方法的内部。<br>成员：在方法的外部，直接写在类当中。</p></li><li><p>作用范围不一样(<strong>重点</strong>)<br>局部：只在方法当中才有用，出了方法就不能用了。<br>成员：整个类都能使用。</p></li><li><p>默认值不同(<strong>重点</strong>)<br>局部：没有默认值，要想用，必须手动赋值。<br>成员：如果没有赋值，会有默认值，规则和数组一样。</p></li><li><p>内存的位置不一样(<strong>了解</strong>)<br>局部：位于栈内存。<br>成员：位于堆内存。</p></li><li><p>生命周期不一样(<strong>了解</strong>)<br>局部：随着方法进栈而诞生，随着方法的出栈而消失。<br>成员：随着对象创建而诞生，随着对象被垃圾回收而消失。</p></li></ul><ol start="3"><li><p>封装就是将一些细节信息隐藏起来，对外界不可见。</p></li><li><p>构造方法是专门用来创建对象的方法，当我们利用关键字new来创建对象时，其实就是调用的构造方法。格式如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//无参构造方法</span><span class="token keyword">public</span> <span class="token function">class_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 方法体<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//有参构造方法</span><span class="token keyword">public</span> <span class="token function">class_name</span><span class="token punctuation">(</span>type name<span class="token punctuation">)</span><span class="token punctuation">{</span> 方法体<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol><li><p>在继承中，“子类就是一个父类”，就是说子类可以被当成一个父类看待。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//父类格式：</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Fu_class</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//子类格式：</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Zi_class</span> <span class="token keyword">extends</span> <span class="token class-name">Fu_class</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在子类中，访问变量的方式如下：</p><pre class="line-numbers language-java"><code class="language-java">局部变量：name本类成员变量：<span class="token keyword">this</span><span class="token punctuation">.</span>name父类成员变量：<span class="token keyword">super</span><span class="token punctuation">.</span>name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>重写((override)):在继承关系中，方法名称一样，参数列表也<strong>一样</strong>。<br>重载((overload)):方法名称一样，参数列表<strong>不一样</strong>。</p></li><li><p>重写注意事项：</p></li></ol><ul><li>必须保证父子类之间的名称相同，参数列表也相同,利用<code>@Override</code>来检测是不是有效的覆盖重写<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">name</span><span class="token punctuation">(</span>type parameter_name<span class="token punctuation">)</span><span class="token punctuation">{</span>  方法体<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>子类方法的返回值必须<strong>小于等于</strong>父类方法的返回值范围</li><li>子类方法的权限必须<strong>大于等于</strong>父类方法的权限修饰符<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">></span> <span class="token keyword">protected</span> <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">default</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token keyword">private</span><span class="token comment" spellcheck="true">//default指的是留空，不写</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><ol start="4"><li><p>继承关系中，父类构造方法的访问特点：<br>子类必须调用父类构造方法，不写则赠送一个<code>super()</code>方法，写了则用指定的super调用，super只能有一个，还必须是第一个。</p></li><li><p>继承中super关键字的用法有3种：</p></li></ol><ul><li>在子类的<strong>成员方法</strong>中，访问父类的<strong>成员变量</strong>。</li><li>在子类的<strong>成员方法</strong>中，访问父类的<strong>成员方法</strong>。</li><li>在子类的<strong>构造方法</strong>中，访问父类的<strong>构造方法</strong>。</li></ul><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ol><li><p>抽象方法：在权限修饰符后加上<code>abstract</code>关键字，去掉大括号，分号结束。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">method_name</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>抽象类：在class前加上<code>abstract</code>即为抽象类。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">class_name</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用抽象类和抽象方法：</p></li></ol><ul><li>不能直接<code>new</code>（创建）抽象类对象</li><li>必须用一个子类来继承抽象父类</li><li>子类必须覆盖重写（去掉<code>abstract</code>关键字，写方法体）抽象父类中的所有抽象方法</li><li>创建子类对象进行使用</li></ul><h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h2><ol><li>接口使用步骤：</li></ol><ul><li><p>建立一个<code>Interface</code>类，里边写抽象方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Interface <span class="token class-name">Interface_name</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>接口不能直接使用，必须有一个“实现类”来“实现”该接口</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">imp_name</span> <span class="token keyword">implements</span> <span class="token class-name">Interface_name</span><span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>接口的实现类必须覆盖重写（实现）接口中<strong>所有</strong>的抽象类</p></li><li><p>创建实现类的对象，进行使用</p></li></ul><ol start="2"><li><p>接口中定义”成员变量”，使用<code>public static final</code>进行修饰，格式：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//其中public static final可以省略，但是不写，默认也是这样</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> type var_name <span class="token operator">=</span> value<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>类-接口：</p></li></ol><ul><li>类与类之间是单继承，直接父类只有一个</li><li>类与接口之间是多实现的，一个类可以实现多个接口</li><li>接口与接口之间是多继承的</li><li>多个父接口之间当中的抽象方法如果重复，没有关系</li><li>多个父接口当中的默认方法（<code>defaule</code>关键字）如果重复，那么子接口必须进行默认方法的重写</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ol><li><p>其实就是一句话：父类引用指向子类对象，格式：</p><pre class="line-numbers language-java"><code class="language-java">Fu_class obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Zi_class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//or</span>Interface_name obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">implements_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>多态下成员变量、成员方法使用口诀：</p></li></ol><ul><li>成员变量：编译看左边，运行看左边</li><li>成员方法：编译看左边，运行看右边</li></ul><ol start="3"><li>对象的转型</li></ol><ul><li><p>对象的向上转型，其实就是多态写法，格式：</p><pre class="line-numbers language-java"><code class="language-java">Fu_class obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Zi_class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>对象的向下转型，其实就是[<strong>还原</strong>]动作，格式：</p><pre class="line-numbers language-java"><code class="language-java">Zi_class obj <span class="token operator">=</span> <span class="token punctuation">(</span>Zi_class<span class="token punctuation">)</span> <span class="token function">Fu_obj_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>instance of</code>会得到一个<code>boolean</code>值结果，判断前边的对象能不能作为后边类型的实例</p><pre class="line-numbers language-java"><code class="language-java">obj instance of class_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="Final关键字"><a href="#Final关键字" class="headerlink" title="Final关键字"></a>Final关键字</h2><ol><li><p>final关键字来修饰一个类的时候，表示这个类不能有任何子类，格式：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">class_name</span><span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>final关键字来修饰一个方法时，这个方法是最终方法，不能覆盖重写，格式：</p><pre class="line-numbers language-java"><code class="language-java">修饰符 <span class="token keyword">final</span> 返回值类型 <span class="token function">method_name</span><span class="token punctuation">(</span>type parameter_name<span class="token punctuation">)</span><span class="token punctuation">{</span> 方法体<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>tips：对于类和方法来说，abstract和final关键字不能同时使用，相互矛盾。</p></blockquote></li><li><p>final修饰成员变量时，成员变量不再给默认值，要么直接赋值，要么通过构造方法赋值</p></li></ol><h2 id="四种权限修饰符"><a href="#四种权限修饰符" class="headerlink" title="四种权限修饰符"></a>四种权限修饰符</h2><table><thead><tr><th align="center">范围</th><th align="center">public</th><th align="center">protected</th><th align="center">((default))</th><th align="center">private</th></tr></thead><tbody><tr><td align="center">同一个类（我自己）</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">同一个包（我领居）</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">不同包子类（我儿子）</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">不同包非子类（陌生人）</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ol><li><p>成员内部类定义格式：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">out_class_name</span><span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">in_class_name</span><span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>tips：内部类用外部类，随意访问；外部类用内部类，需要内部对象。</p></blockquote><p>新建成员内部类对象：</p><pre class="line-numbers language-java"><code class="language-java">out_class_name<span class="token punctuation">.</span>in_class_name obj <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">out_class_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">in_class_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>局部内部类：只有当前所属的方法才可以使用它，出了这个方法外边就不能用了，格式：</p><pre class="line-numbers language-java"><code class="language-java">修饰符 <span class="token keyword">class</span> <span class="token class-name">out_class_name</span><span class="token punctuation">{</span> 修饰符 返回值类型 <span class="token function">out_method_name</span><span class="token punctuation">(</span>type parameter_name<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">class</span> <span class="token class-name">in_class_name</span><span class="token punctuation">{</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>tips：局部内部类，如果想要访问所在方法的局部变量，那么这个局部变量必须是<strong>有效的final</strong>。这是由于生命周期所决定：</p><ul><li>局部变量，跟着方法→位于栈内存→方法运行结束，立刻出栈，局部变量消失。</li><li>new出来的对象→位于堆内存→对象一直位于堆内存，直到垃圾回收清理。</li></ul></blockquote></li><li><p>使用内部类时，权限修饰符规则：</p></li></ol><ul><li>外部类：(public) / ((default))</li><li>成员内部类：(public) / (protected) / ((default)) / (private)</li><li>局部内部类：什么都不写</li></ul><ol start="4"><li><p>匿名内部类：如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用<strong>匿名内部类</strong>，格式为：</p><pre class="line-numbers language-java"><code class="language-java">Interface_name obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Interface_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//覆盖重写全部抽象方法</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>tips：</p><ul><li>匿名内部类在<strong>创建对象</strong>的时候，只能使用<strong>唯一一次</strong></li><li>匿名对象在<strong>调用方法</strong>的时候，只能调用<strong>唯一一次</strong></li><li>匿名内部类省略了<strong>实现类/子类名称</strong>，但是匿名对象省略了<strong>对象名称</strong>。<strong>匿名内部类和匿名对象不是一回事</strong></li></ul></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVPR2019目标检测算法总结</title>
      <link href="/2019/09/28/cvpr2019/"/>
      <url>/2019/09/28/cvpr2019/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=441442&auto=1&height=66"></iframe></div><blockquote><p>介绍一下目标检测主要的优化方向，以及CVPR2019中目标检测相关的论文。</p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><hr><p>目标检测是很多计算机视觉应用的基础，比如实例分割、人体关键点提取、人脸识别等，它结合了目标分类和定位两个任务。</p><p>现代大多数目标检测器的框架是 (two-stage/single-stage)，目标检测被定义为一个多任务学习的过程，主要包括：</p><ul><li><p>区分前景物体与背景，并给它们分配恰当的类别标签。</p></li><li><p>回归相应的位置参数，最大化检测框与<strong>GT bounding box</strong>的交并比((IoU))或是其他指标。</p></li></ul><h1 id="目标检测主要的优化方向"><a href="#目标检测主要的优化方向" class="headerlink" title="目标检测主要的优化方向"></a>目标检测主要的优化方向</h1><hr><p>二维目标检测实现和优化方向包括backbone、IoU、损失函数、NMS、anchor、one shot learning/zero shot learning等。<br><br><strong>基于目标检测的backbone和特征提取</strong><br>目标检测的backbone一般是基于ImageNet预训练的图像分类网络。图像的分类只关注分类以及感受视野，不用关注目标的定位，目标检测同时还要关注图片的空间信息。如果下采样过多，会导致最后的Feature map很小，小目标很容易被忽略。现在很多基础网络，ResNet、MaskR-CNN、DenseNet、FPN、DetNet、RetinNet等能够提取图像的上下文信息，在特征提取上不断优化。<br><br><strong>基于位置回归的优化算法</strong><br>包括UnitBox、IoU-Net，能够预测检测到的边界框和它们对应的GT bounding box之间的IoU，使得该网络能像其分类模块一样，对检测框的定位精确程度有所掌握，神经网络在Backbone引入IoU-Net做边界修订。<br><br><strong>基于优化损失函数的方法</strong><br>主要有Smooth L1 loss、Smooth L2 loss、Focal loss等<br><br><strong>基于优化NMS的方法</strong><br>主要有Soft-NMS,Softer-NMS,以及Relation Netwrok，ConvNMS，NMS Network，Yes-Net等<br><br><strong>基于Anchor生成的算法</strong><br>有Sliding window、Region Proposal Network（RPN）、CornerNet、meta-anchor等。<br><br><strong>One-shot learning以及Zero shot learning</strong><br>都属于迁移学习领域主要研究的是网络少样本精准分类问题，单样本学习能力。</p><h1 id="GIoU"><a href="#GIoU" class="headerlink" title="GIoU"></a>GIoU</h1><hr><p><a href="http://openaccess.thecvf.com/content_CVPR_2019/papers/Rezatofighi_Generalized_Intersection_Over_Union_A_Metric_and_a_Loss_for_CVPR_2019_paper.pdf" target="_blank" rel="noopener"><strong>论文下载</strong></a></p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>包围框回归是2D/3D视觉任务中的重要模块，不管是目标检测，目标跟踪，还是实例分割，都依赖于对bounding box进行回归，以获得准确的定位效果。</p><p>其中IoU((Intersection\ over\ Union))是使得包围框回归的重要参数。简单来讲就是模型产生的目标框((Result))与 (GT) 的重叠率。可以理解为检测结果与GT的交集比上它们的并集，公式为：</p><p>$$IoU=\frac{Result\bigcap GT}{Result\bigcup GT}$$</p><p>IoU是目标检测中一个重要的概念，在anchor-based的方法中，他的作用不仅用来确定正样本和负样本，还可以用来评价输出框((predict\ box))和(Ground\ Truth)的距离，或者说(predict\ box)的准确性。IoU有一个好的特性就是对尺度不敏感((scale\ invariant))。</p><p>在regression任务中，判断predict box和gt的距离最直接的指标就是IoU，但所采用的loss却不适合，如图所示，在loss相同的情况下，regression的效果却大不相同，也就是说loss没有体现出regression的效果，而IoU却可以根据不同的情况得到不同的数值，能最直接反应回归效果。</p><p><img src="1.png" alt></p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>本文提出用IoU这个直接指标来指导bounding box的回归。与其用一个代理的损失函数来监督学习，不如直接用指标本身来的好。此时损失函数为：<br>$$L_{IoU}=1-IoU$$</p><p>但是直接使用IoU作为损失函数会出现两个问题:</p><ul><li>如果两个框没有相交，根据定义，IoU=0，不能反映两者的距离大小（重合度）。同时因为loss=0，没有梯度回传，无法进行学习训练。</li><li>IoU无法精确的反映两者的重合度大小。如图所示，三种情况IoU都相等，但看得出来他们的重合度是不一样的，左边的图回归的效果最好，右边的最差。<br><img src="2.png" alt></li></ul><p>针对IoU的两个缺点，论文提出了一个新的指标<strong>GIoU</strong>((Generalized\ Intersection\ over\ Union))，如图所示：<br><img src="3.png" alt></p><p>GIoU的定义很简单，就是先计算两个框的最小闭包区域面积，再计算IoU，再计算闭包区域中不属于两个框的区域占闭包区域的比重，最后用IoU减去这个比重得到GIoU。GIoU有如下4个特点：</p><ul><li><p>与IoU相似，GIoU也是一种距离度量，作为损失函数的话，满足损失函数的基本要求。$$L_{GIoU}=1-GIoU$$</p></li><li><p>GIoU对scale不敏感。</p></li><li><p>GIoU是IoU的下界，在两个框无线重合的情况下，IoU=GIoU。</p></li><li><p>IoU取值[0,1]，但GIoU有对称区间，取值范围[-1,1]。在两者重合的时候取最大值1，在两者无交集且无限远的时候取最小值-1，因此GIoU是一个非常好的距离度量指标。</p></li><li><p>与IoU只关注重叠区域不同，GIoU不仅关注重叠区域，还关注其他的非重合区域，能更好的反映两者的重合度。</p></li></ul><p>其实GIoU不仅定义简单，在2D目标检测中计算方式也很简单，计算重合区域和IoU一样，计算最小闭包区域只需要得到两者max和min坐标，坐标围成的矩形就是最小闭包区域。</p><p>GIoU和IoU作为loss的算法如下所示：<br><img src="4.png" alt></p><p>步骤为：</p><ul><li>分别计算GT和Predict Box的面积</li><li>计算Intersection的面积</li><li>计算最小闭包区域面积</li><li>计算IoU和GIoU</li><li>根据公式得到loss</li></ul><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>GIoU loss可以替换掉大多数目标检测算法中bounding box regression，本文选取了Faster R-CNN、Mask R-CNN和YOLO v3 三个方法验证GIoU loss的效果。实验在Pascal VOC和MS COCO数据集上进行。</p><p>效果如下：</p><p><img src="5.png" alt><br><img src="6.png" alt><br><img src="7.png" alt></p><p>可以看出YOLOv3在COCO上有明显涨点，但在其他模型下涨点并不明显，作者也指出了faster rcnn和mask rcnn效果不明显的原因是anchor很密，GIoU发挥作用的情况并不多。</p><p>总体来说，文章的motivation比较好，指出用L1、L2作为regression损失函数的缺点，以及用直接指标IoU作为损失函数的缺陷性，提出新的metric来代替L1、L2损失函数，从而提升regression效果，想法简单粗暴，但work的场景有很大局限性。</p>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DeepLearning </tag>
            
            <tag> 目标检测 </tag>
            
            <tag> CVPR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Github-Netlify博客搭建教程</title>
      <link href="/2019/09/25/blog/"/>
      <url>/2019/09/25/blog/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=591241&auto=1&height=66"></iframe></div><blockquote><p>主要讲解本blog的搭建过程，如有不详之处，可以联系我，或者在下方评论，我都会解答哒😁。</p></blockquote><h1 id="我的博客源代码地址"><a href="#我的博客源代码地址" class="headerlink" title="我的博客源代码地址"></a>我的博客源代码地址</h1><hr><p>大家有需要的可以star&amp;fork我的<a href="https://github.com/Plutoxxx/Blog" target="_blank" rel="noopener">博客代码</a>，修改一些配置就可以写文章了。</p><h1 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h1><hr><p>如果你不想重新自定义主题的话，可以直接下载我已经修改过的主题，只要稍微修改一些地方就行：</p><ul><li>在根目录配置文件_config.yml和themes config.yml中修改个人信息。</li><li>在/_config.yml中修改deploy下的repository。</li><li>在/_config.yml中修改baidu_url_submit下的host。</li><li>在themes/_config.yml中修改gitalk。</li></ul><p><strong>当然在个性化设置前环境要先配置好</strong></p><p>平时常用的命令有：</p><pre class="line-numbers language-java"><code class="language-java">hexo n <span class="token string">"博客名称"</span>  <span class="token operator">=</span><span class="token operator">></span> hexo <span class="token keyword">new</span> <span class="token string">"博客名称"</span>   #这两个都是创建新文章，前者是简写模式hexo p  <span class="token operator">=</span><span class="token operator">></span> hexo publish   hexo g  <span class="token operator">=</span><span class="token operator">></span> hexo generate  #生成静态网页hexo s  <span class="token operator">=</span><span class="token operator">></span> hexo server    #启动服务预览hexo d  <span class="token operator">=</span><span class="token operator">></span> hexo deploy    #部署hexo clean   #清除缓存，网页正常情况下可以忽略此条命令ctrl <span class="token operator">+</span> c     #关闭本地服务器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><hr><p>首先下载稳定版本<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>。</p><p>安装选项默认就行，一路Next。</p><p>最后安装好之后，按Win+R打开命令提示符，输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p><p><strong>添加国内镜像源</strong></p><p>如果没梯子可以使用阿里的国内镜像进行加速</p><pre class="line-numbers language-js"><code class="language-js">npm config <span class="token keyword">set</span> registry https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>registry<span class="token punctuation">.</span>npm<span class="token punctuation">.</span>taobao<span class="token punctuation">.</span>org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><hr><p>安装完Node.js后，打开终端，输入以下命令：</p><pre class="line-numbers language-hexo"><code class="language-hexo">npm install -g hexo-clihexo -v  #查看是否安装成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在合适的位置新建文件夹，用来存放blog文件，比如我的博客文件在 F:\Project\GitHub\Blog 目录下。</p><p>在该目录下初始化网站，输入 <code>hexo init</code> 初始化文件夹，接着输入 <code>npm install</code> 安装必要组件。 </p><p>到这里，本地网站已经配置结束，输入 <code>hexo g</code> 生成静态网页，然后输入 <code>hexo s</code> 打开本地服务器，</p><p>最后在浏览器中打开: <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就能看到初始化的blog啦。</p><p>最后按 <code>ctrl+c</code> 就能关闭本地服务器了</p><h1 id="安装Git和创建GitHub仓储"><a href="#安装Git和创建GitHub仓储" class="headerlink" title="安装Git和创建GitHub仓储"></a>安装Git和创建GitHub仓储</h1><hr><p><strong>安装Git</strong></p><p>先到<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git官网</a>下载软件。</p><p>安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入 <code>git --version</code> 验证是否安装成功。</p><p><strong>创建GitHub仓储</strong></p><p>到<a href="https://github.com" target="_blank" rel="noopener">GitHub</a>注册一个账号，相信小伙伴们都有吧。然后新建一个项目，如图所示：<br><img src="1.png" alt></p><p>然后设置一下Repository的名字，如图所示，不要勾选下边的 <code>Initalize this repository with a README</code>如下图所示，点击完成就行。<br><img src="2.png" alt></p><h1 id="本地连接GitHub"><a href="#本地连接GitHub" class="headerlink" title="本地连接GitHub"></a>本地连接GitHub</h1><hr><p>右击打开 <code>Git Bash here</code> ，输入:ssh，如图所示，说明配置好了：<br><img src="3.png" alt></p><p>接着输入 <code>ssh-keygen -t rsa</code> （(主要是生成你跟github联系的秘钥key)）连续三个回车，key就生成了。打开C盘用户下的.ssh文件，其中 <code>id_rsa</code> 代表私钥， <code>id_rsa.pub</code> 代表公钥。</p><p>将id_rsa.pub下的内容复制出来，打开GitHub下的Settings<br><img src="4.png" alt></p><p>选择 <code>SSH and GPG keys</code> 中的 <code>New SSH key</code>粘贴进去就行了<br><img src="5.png" alt></p><p>测试连接 <code>ssh -T git@github.com</code>，弹出警告后，填写yes，然后回车，出现以下则表示成功<br><img src="6.png" alt></p><p>在Blog目录下，右击打开Git，输入命令： <code>git init</code>，会出现一个 <code>.git</code> 文件夹</p><p>在项目根目录下,将你的本地项目和新建的repository联系起来:</p><pre class="line-numbers language-git"><code class="language-git">git remote add origin https://github.com/your-name/your-Repository.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完成后到根目录下：</p><pre class="line-numbers language-git"><code class="language-git">git add .                       # 添加文件到暂缓区git commit -m <span class="token string">'First commit'</span>    # 将刚刚添加到暂缓区的内容提交到本地仓库.gitgit push --set-upstream origin master #上传到远程仓库(由于是第一次push,所以是这个命令)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>到这里,我们已经将我们的项目推送到GitHub的master分支下面了.接下来我们要对hexo进行一些配置:</p><p>打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。<br>修改最后一行的配置：</p><pre class="line-numbers language-config"><code class="language-config">deploy: type: git #部署方式 repository: git@github.com:you-name/your-Repository.git #关联github仓库 branch: run-page #部署分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在这里,我们将在这个项目仓库下新建一个run-page分支,至于有什么用,我等一下解释,先跟着我操作起来.</p><p>在当前根目录下将不需要同步的文件和目录写到 <code>.gitignore</code> :</p><pre class="line-numbers language-name"><code class="language-name">.DS_StoreThumbs.dbdb.json*.lognode_modules/themes/.deploy*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置好了之后,保存退出,我们重新执行一下:</p><pre class="line-numbers language-hexo"><code class="language-hexo">$ hexo clean #清理各种缓存和旧文件$ hexo g     #生成静态文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最后,我们将public目录同步到Github:</p><pre class="line-numbers language-hexo"><code class="language-hexo">$ hexo d #部署应用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在执行这个命令的时候,我们可能会出现如下错误：</p><pre class="line-numbers language-error"><code class="language-error">$ ERROR Deployer not found: git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那是因为我们缺少一个依赖,我们安装一下:</p><pre class="line-numbers language-npm"><code class="language-npm">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再次执行一下,执行完成我们到Github，神奇的的事发生了，我们的项目多了一个(run-page),这个分支就是我们后面要用来生成我们到静态页面的。</p><h1 id="部署到Netlify"><a href="#部署到Netlify" class="headerlink" title="部署到Netlify"></a>部署到Netlify</h1><hr><p>我们先到<a href="https://www.netlify.com" target="_blank" rel="noopener">Netlify</a>官网注册一下账号,因为我们是将项目托管到GitHub的,所以我们选择GitHub登录：<br><img src="7.png" alt><br>点击网站新建：<br><img src="8.png" alt></p><p>选择GitHub来源：<br><img src="9.png" alt></p><p>选择刚建的项目：<br><img src="10.png" alt></p><p>进行下一步配置：<br><img src="11.png" alt></p><p>等待一会，Netlify会帮我们生成网站：<br><img src="12.png" alt></p><p>第一次新建的时候,它会随机生成一个Netlify的二级域名,我们可以进行自定义二级域名,点击(“Change site name”)即可进行设置,像这样：<br><img src="14.png" alt><br><img src="15.png" alt></p><p>点击Save,等待Netlify进行热部署即可.</p><p>然后点击创建好的二级域名,成功访问✌️！！！</p><p>以后我们写好博客之后,直接执行：</p><pre class="line-numbers language-hexo"><code class="language-hexo">$ hexo clean #清理各种缓存和旧文件$ hexo g     #生成静态文件$ hexo s     #在本地查看生成网页（取消用ctrl+c）$ hexo d     #推送到GitHub# 写完blog不需要清除缓存，直接生成静态文件即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们的个人博客就会自动进行刷新,是不是超厉害！！</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><hr><p>部署完成之后,可能有的同学会觉得很晕,我画了一个部署的流程图：<br><img src="13.png" alt><br>这就是我们为什么要利用两个分支的原因,我们将我们的项目分支托管到 <code>master</code> ,然后将生成的 <code>public</code> 目录,托管到 <code>run-page</code> 分支,以后我们可以写完博客以后,就可以直接输入：</p><pre class="line-numbers language-hexo"><code class="language-hexo">$ hexo clean #清理各种缓存和旧文件$ hexo g     #生成静态文件$ hexo s     #在本地查看生成网页（取消用ctrl+c）$ hexo d     #推送到GitHub# 写完blog不需要清除缓存，直接生成静态文件即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进行我们博客的推送,一旦我们推送到run-page分支,Netlify监测到我们的仓库发生了变化,就会根据这个分支的变化进行实时拉取并部署。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
            <tag> Netlify </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
